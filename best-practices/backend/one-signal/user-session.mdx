---
title: "User Session"
description: "Complete implementation guide for OneSignal push notifications with a unified "app_user_id" that works across your database, RevenueCat, and OneSignal."
---

## The Universal User Index

`app_user_id` is a single identifier that tracks users across all services:

```mermaid
flowchart TB
    subgraph Universal["app_user_id = 'abc123' (Universal User Index)"]
        direction LR
        Vault["Storage Vault<br/><br/>app_user_id<br/>= 'abc123'"]
        DB["Your Database<br/><br/>app_user_id<br/>= 'abc123'"]
        RC["RevenueCat<br/><br/>app_user_id<br/>= 'abc123'"]
        OS["OneSignal<br/><br/>external_user_id<br/>= 'abc123'"]
    end
    
    style Universal fill:#e1f5e1,stroke:#4a9
    style Vault fill:#fff,stroke:#333
    style DB fill:#fff,stroke:#333
    style RC fill:#fff,stroke:#333
    style OS fill:#fff,stroke:#333
```

| Service       | Field Name         | Value                |
| :------------ | :----------------- | :------------------- |
| Storage Vault | `app_user_id`      | `"abc123-vendor-id"` |
| Your Database | `app_user_id`      | `"abc123-vendor-id"` |
| RevenueCat    | `app_user_id`      | `"abc123-vendor-id"` |
| OneSignal     | `external_user_id` | `"abc123-vendor-id"` |

**Why this matters:** When a RevenueCat webhook arrives, you can immediately send a push notification using the same `app_user_id`‚Äîno ID mapping required.

---

## Push Permission Modes

| Mode               | Setting                      | Behavior                                    | When to Use                                      |
| :----------------- | :--------------------------- | :------------------------------------------ | :----------------------------------------------- |
| **Auto (Default)** | Manual Push Permission = OFF | Prompt shows automatically on first install | Simple apps, quick setup                         |
| **Manual**         | Manual Push Permission = ON  | You control when prompt appears             | Better UX, show prompt after demonstrating value |

<Warning>
  **App Review Rejection Risk:**\
  If manual mode is enabled but you never call `registerpush://`, your app will be rejected by Apple and Google.
</Warning>

---

## User Identity Flow (Self-Healing)

```mermaid
flowchart TD
    Start([APP LAUNCH]) --> ReadVault[Try read app_user_id<br/>from Storage Vault]
    
    ReadVault --> CheckVault{Vault read<br/>successful?}
    
    CheckVault -->|Yes + Has ID| Returning[Use existing ID]
    CheckVault -->|Yes + Empty| CreateNew[Create new from<br/>despia.uuid]
    CheckVault -->|Error/Failed| CreateNew
    
    CreateNew --> TryWriteVault[Try write to Vault<br/>for next launch]
    TryWriteVault --> SetServices
    
    Returning --> SetServices[Set OneSignal ID<br/>Set RevenueCat ID]
    
    SetServices --> SyncBackend[Sync with Backend<br/>POST /api/user/register]
    
    SyncBackend --> CheckAuth{User<br/>Logged In?}
    
    CheckAuth -->|No| StayAnonymous[Stay Anonymous<br/>Continue with<br/>current app_user_id]
    CheckAuth -->|Yes| LoginFlow[POST /api/user/login]
    
    LoginFlow --> CheckAccount{Account has<br/>app_user_id?}
    
    CheckAccount -->|No| Claim[CLAIM<br/>Assign current ID<br/>to account]
    CheckAccount -->|Yes| Recover[RECOVER<br/>Get account's<br/>existing ID]
    
    Claim --> HealVault[Write final ID to Vault<br/>HEALS if was wrong/empty]
    Recover --> HealVault
    
    HealVault --> UpdateServices[Update OneSignal &<br/>RevenueCat with<br/>final app_user_id]
    
    StayAnonymous --> End([Ready])
    UpdateServices --> End
    
    style Start fill:#4a9,color:#fff
    style End fill:#4a9,color:#fff
    style Claim fill:#fff4e1,stroke:#f90
    style Recover fill:#e1f0ff,stroke:#09f
    style CreateNew fill:#ffe1e1,stroke:#f66
    style HealVault fill:#e1f5e1,stroke:#4a9
    style CheckVault fill:#ffe1e1
    style CheckAuth fill:#ffe1e1
    style CheckAccount fill:#ffe1e1
```

### Self-Healing Rules

1. **Vault fails/empty on startup** ‚Üí Create new `app_user_id` from `despia.uuid`, try to save to vault
2. \*\*User logs in with account that has no \*\*`app_user_id` ‚Üí CLAIM: assign current ID to account
3. \*\*User logs in with account that has existing \*\*`app_user_id` ‚Üí RECOVER: use account's ID, heal vault
4. **Always write to vault after login** ‚Üí Ensures vault is synced with account's correct ID
5. **Vault write fails** ‚Üí Continue anyway, login will heal it next time

---

## Login Identity Flow (Self-Healing)

```mermaid
flowchart TD
    Login([User Logs In]) --> GetVault[Try read app_user_id<br/>from Vault]
    
    GetVault --> VaultOK{Vault read<br/>successful?}
    
    VaultOK -->|Yes + Has ID| UseVaultID[Use vault's ID]
    VaultOK -->|Yes + Empty| UseFallback[Use despia.uuid<br/>as fallback]
    VaultOK -->|Error| UseFallback
    
    UseVaultID --> CallBackend
    UseFallback --> CallBackend[POST /api/user/login<br/>accountId + currentAppUserId]
    
    CallBackend --> BackendCheck{Backend Check:<br/>Account has<br/>app_user_id?}
    
    BackendCheck -->|NO| ClaimFlow[CLAIM FLOW]
    BackendCheck -->|YES| RecoverFlow[RECOVER FLOW]
    
    subgraph ClaimBox [" "]
        ClaimFlow --> AssignID[Assign current ID<br/>as account's permanent ID]
        AssignID --> ClaimMerge{Anonymous<br/>data to merge?}
        ClaimMerge -->|Yes| MergeData1[Merge cart, wishlist,<br/>events into account]
        ClaimMerge -->|No| ClaimDone[Done]
        MergeData1 --> ClaimDone
    end
    
    subgraph RecoverBox [" "]
        RecoverFlow --> GetAccountID[Get account's existing<br/>app_user_id]
        GetAccountID --> RecoverMerge{Current ID<br/>was anonymous?}
        RecoverMerge -->|Yes| MergeData2[Merge anonymous data<br/>into account]
        RecoverMerge -->|No| RecoverDone[Done]
        MergeData2 --> RecoverDone
    end
    
    ClaimDone --> ReturnResult[Return final app_user_id<br/>+ action type]
    RecoverDone --> ReturnResult
    
    ReturnResult --> HealVault[ALWAYS write final ID<br/>to Vault - HEALS if wrong]
    
    HealVault --> FrontendUpdate[Update OneSignal &<br/>RevenueCat with final ID]
    
    FrontendUpdate --> Done([Login Complete<br/>Vault is now correct])
    
    style Login fill:#4a9,color:#fff
    style Done fill:#4a9,color:#fff
    style ClaimFlow fill:#fff4e1,stroke:#f90
    style RecoverFlow fill:#e1f0ff,stroke:#09f
    style HealVault fill:#e1f5e1,stroke:#4a9
    style UseFallback fill:#ffe1e1,stroke:#f66
    style BackendCheck fill:#ffe1e1
    style VaultOK fill:#ffe1e1
```

---

## RevenueCat ‚Üí Push Notification Flow

```mermaid
flowchart LR
    subgraph AppStores [App Stores]
        Apple[Apple App Store]
        Google[Google Play Store]
        Stripe[Stripe]
    end
    
    subgraph RC [RevenueCat]
        RCProcess[Process Purchase<br/>Track Subscription]
    end
    
    subgraph Backend [Your Backend]
        Webhook[Webhook Handler<br/>/webhooks/revenuecat]
        DB[(Database)]
        PushLogic[Push Logic]
    end
    
    subgraph OneSignal [OneSignal]
        OSApi[OneSignal API<br/>external_user_id = app_user_id]
    end
    
    subgraph User [User's Device]
        Push[Push Notification]
    end
    
    Apple --> RCProcess
    Google --> RCProcess
    Stripe --> RCProcess
    
    RCProcess -->|Webhook with<br/>app_user_id| Webhook
    
    Webhook --> DB
    Webhook --> PushLogic
    
    PushLogic -->|Same app_user_id| OSApi
    
    OSApi --> Push
    
    style Apple fill:#333,color:#fff
    style Google fill:#4a9,color:#fff
    style Stripe fill:#635bff,color:#fff
    style RCProcess fill:#f8485e,color:#fff
    style OSApi fill:#e54b4d,color:#fff
```

---

## Webhook Event ‚Üí Push Notification

```mermaid
flowchart TD
    Webhook([RevenueCat Webhook]) --> Extract[Extract app_user_id<br/>from event]
    
    Extract --> Switch{Event Type?}
    
    Switch -->|INITIAL_PURCHASE| Purchase["üéâ Welcome to Premium!<br/>Thank you for subscribing"]
    Switch -->|TRIAL_STARTED| Trial["üéâ Trial Started!<br/>Explore premium features"]
    Switch -->|BILLING_ISSUE| Billing["‚ö†Ô∏è Payment Issue<br/>Update payment method"]
    Switch -->|CANCELLATION| Cancel["Before you go...<br/>Tell us what went wrong"]
    Switch -->|EXPIRATION| Expire["We miss you! üëã<br/>Come back for 20% off"]
    Switch -->|RENEWAL| Renew["‚úÖ Subscription Renewed<br/>Thanks for staying"]
    
    Purchase --> Send[Send to OneSignal<br/>include_external_user_ids:<br/>app_user_id]
    Trial --> Send
    Billing --> Send
    Cancel --> Schedule[Schedule for 24h later]
    Expire --> Send
    Renew --> Send
    
    Schedule --> Send
    
    Send --> Deliver[Deliver to User's Device]
    
    style Webhook fill:#f8485e,color:#fff
    style Send fill:#e54b4d,color:#fff
    style Deliver fill:#4a9,color:#fff
    style Billing fill:#fff4e1,stroke:#f90
    style Cancel fill:#ffe1e1,stroke:#f00
```

---

## Anonymous User Journey

```mermaid
sequenceDiagram
    participant App as App
    participant Vault as Storage Vault
    participant Backend as Backend
    participant OS as OneSignal
    participant RC as RevenueCat
    
    Note over App: First App Launch
    
    App->>Vault: Try read app_user_id
    Vault-->>App: Not found (new device)
    
    App->>App: Generate from despia.uuid<br/>app_user_id = "abc123"
    
    App->>Vault: Try write app_user_id = "abc123"
    Vault-->>App: Success (or fail - continue anyway)
    
    App->>OS: setonesignalplayerid://?user_id=abc123
    App->>RC: setrevenuecatuserid://?user_id=abc123
    
    App->>Backend: POST /api/user/register<br/>{appUserId: "abc123", isAnonymous: true}
    Backend-->>App: {success: true}
    
    Note over App: User browses app anonymously
    Note over App: Adds items to cart
    Note over App: RevenueCat tracks as "abc123"
    
    Note over App: User decides to sign up / log in
    
    App->>Vault: Try read app_user_id
    Vault-->>App: "abc123"
    
    App->>Backend: POST /api/user/login<br/>{accountId: "user_456", currentAppUserId: "abc123"}
    
    Backend->>Backend: Account has no app_user_id yet<br/>CLAIM: Assign "abc123" to account
    Backend->>Backend: Mark anonymous user as claimed
    
    Backend-->>App: {action: "claimed", appUserId: "abc123"}
    
    App->>Vault: Write "abc123" (confirms/heals)
    
    Note over App: Same ID, now linked to account<br/>Anonymous data preserved
```

---

## Returning User Journey (Different Device)

```mermaid
sequenceDiagram
    participant App as New Device
    participant Vault as Storage Vault (iCloud Sync)
    participant Backend as Backend
    participant OS as OneSignal
    participant RC as RevenueCat
    
    Note over App: User opens app on new device
    
    App->>Vault: Read app_user_id
    Vault-->>App: "abc123" (synced via iCloud)
    
    Note over App: Vault already has ID from other device!
    
    App->>OS: setonesignalplayerid://?user_id=abc123
    App->>RC: setrevenuecatuserid://?user_id=abc123
    
    App->>Backend: POST /api/user/register<br/>{appUserId: "abc123"}
    Backend-->>App: {success: true, isReturning: true,<br/>accountId: "user_456"}
    
    Note over App: User already recognized!<br/>Same identity across devices
```

---

## Account Recovery Journey (Self-Healing)

```mermaid
sequenceDiagram
    participant App as App
    participant Vault as Storage Vault
    participant Backend as Backend
    participant OS as OneSignal
    participant RC as RevenueCat
    
    Note over App: User reinstalls app<br/>Vault empty or corrupted
    
    App->>Vault: Try read app_user_id
    Vault-->>App: Error or empty
    
    App->>App: Generate fallback ID<br/>app_user_id = "xyz789"
    
    App->>Vault: Try write "xyz789"
    Note over Vault: May succeed or fail
    
    App->>OS: setonesignalplayerid://?user_id=xyz789
    App->>RC: setrevenuecatuserid://?user_id=xyz789
    
    App->>Backend: POST /api/user/register<br/>{appUserId: "xyz789"}
    
    Note over App: User logs into existing account
    
    App->>Vault: Try read app_user_id
    Vault-->>App: "xyz789" (or error)
    
    App->>Backend: POST /api/user/login<br/>{accountId: "user_456", currentAppUserId: "xyz789"}
    
    Backend->>Backend: Account already has app_user_id = "abc123"<br/>RECOVER: Use account's existing ID
    Backend->>Backend: Merge any anonymous "xyz789" data
    
    Backend-->>App: {action: "recovered", appUserId: "abc123"}
    
    Note over App: SELF-HEALING: Write correct ID to vault
    
    App->>Vault: Write "abc123"
    Note over Vault: Vault now has correct ID!
    
    App->>OS: setonesignalplayerid://?user_id=abc123
    App->>RC: setrevenuecatuserid://?user_id=abc123
    
    Note over App: Identity recovered!<br/>Vault healed with correct "abc123"
```

---

## Multi-Account Switch

```mermaid
sequenceDiagram
    participant App as App
    participant Vault as Storage Vault
    participant Backend as Backend
    participant OS as OneSignal
    participant RC as RevenueCat
    
    Note over App: User logged in as Account A<br/>app_user_id = "abc123"
    
    App->>App: User switches to Account B
    
    App->>Backend: GET /api/user/get-app-user-id/account_B
    Backend-->>App: {appUserId: "def456"}
    
    App->>Vault: Update to "def456"
    App->>OS: setonesignalplayerid://?user_id=def456
    App->>RC: setrevenuecatuserid://?user_id=def456
    
    Note over App: Now using Account B's identity<br/>No data merge (both are real accounts)
    
    App->>App: User switches back to Account A
    
    App->>Backend: GET /api/user/get-app-user-id/account_A
    Backend-->>App: {appUserId: "abc123"}
    
    App->>Vault: Update to "abc123"
    App->>OS: setonesignalplayerid://?user_id=abc123
    App->>RC: setrevenuecatuserid://?user_id=abc123
    
    Note over App: Back to Account A's identity
```

---

## Database Schema

```
erDiagram
    app_users ||--o{ user_devices : "has"
    app_users ||--o| user_subscriptions : "has"
    app_users ||--o| accounts : "linked to"
    
    app_users {
        serial id PK
        varchar app_user_id UK "Universal ID"
        varchar device_id
        varchar platform
        boolean is_anonymous
        varchar account_id FK
        timestamp claimed_at
        boolean push_enabled
        timestamp last_seen
    }
    
    user_devices {
        serial id PK
        varchar device_id UK
        varchar app_user_id FK
        varchar account_id
        varchar platform
        boolean push_enabled
        timestamp last_seen
    }
    
    user_subscriptions {
        serial id PK
        varchar app_user_id FK "Same Universal ID"
        boolean is_active
        varchar subscription_status
        varchar product_id
        jsonb entitlements
        timestamp expires_at
        boolean billing_issue
    }
    
    accounts {
        serial id PK
        varchar app_user_id UK "Claimed ID"
        varchar email
        varchar name
        timestamp created_at
    }
    
    notification_logs {
        serial id PK
        varchar notification_id
        jsonb app_user_ids
        varchar title
        text message
        varchar trigger_event
        timestamp sent_at
    }
```

---

## Frontend Implementation

### Platform Detection

```javascript
// Platform detection
const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');
const isIOS = ua.includes('despia-iphone') || ua.includes('despia-ipad');
const isAndroid = ua.includes('despia-android');
```

### App Startup

```javascript
import despia from 'despia-native';

// ==========================================
// APP STARTUP - Call on every app launch
// Self-healing: creates new ID if vault fails/empty
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  let appUserId;
  
  // Try to read existing app_user_id from vault
  try {
    const vaultData = await despia('readvault://?key=app_user_id', ['app_user_id']);
    appUserId = vaultData?.app_user_id;
  } catch (error) {
    // Vault read failed - will create new ID below
    console.log('Vault read failed:', error);
  }
  
  // If vault empty or failed, create new app_user_id
  // This self-heals when vault data is missing
  if (!appUserId) {
    appUserId = despia.uuid;
    console.log('Created new app_user_id:', appUserId);
    
    // Store in vault for next launch
    try {
      await despia(`setvault://?key=app_user_id&value=${appUserId}&locked=false`);
    } catch (error) {
      console.log('Vault write failed:', error);
      // Continue anyway - login will recover/sync the correct ID
    }
  }
  
  // Set OneSignal external_user_id
  despia(`setonesignalplayerid://?user_id=${appUserId}`);
  
  // Set RevenueCat app_user_id
  despia(`setrevenuecatuserid://?user_id=${appUserId}`);
  
  // Register with backend
  await fetch('/api/user/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      appUserId,
      deviceId: despia.uuid,
      platform: ua.includes('android') ? 'android' : 'ios',
      appVersion: despia.appversion,
      timestamp: new Date().toISOString()
    })
  });
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web push setup...
  // E.g. OneSignal Web SDK (suggested), or other web push provider
}
```

### User Login

```javascript
// ==========================================
// USER LOGIN - Critical identity merge point
// Self-healing: recovers correct ID from account if vault was wrong/empty
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  // Get current app_user_id from vault (may be temporary if vault failed earlier)
  let currentAppUserId;
  try {
    const vaultData = await despia('readvault://?key=app_user_id', ['app_user_id']);
    currentAppUserId = vaultData?.app_user_id;
  } catch (error) {
    // Vault failed - use device ID as fallback
  }
  
  if (!currentAppUserId) {
    currentAppUserId = despia.uuid;
  }
  
  // Send to backend for CLAIM or RECOVER
  const response = await fetch('/api/user/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      accountId: user.id,  // From your auth system
      currentAppUserId,
      deviceId: despia.uuid,
      platform: ua.includes('android') ? 'android' : 'ios',
      timestamp: new Date().toISOString()
    })
  });
  
  const result = await response.json();
  
  /*
   * Backend returns one of two actions:
   * 
   * CLAIM (account has no app_user_id):
   *   - Assigns currentAppUserId to account permanently
   *   - Returns { action: 'claimed', appUserId: currentAppUserId }
   *   - Vault stays the same
   * 
   * RECOVER (account already has app_user_id):
   *   - Returns account's existing app_user_id
   *   - Returns { action: 'recovered', appUserId: accountsExistingId }
   *   - Must update vault to sync with account
   *   - This HEALS the vault if it was wrong/empty
   */
  
  // Always update vault with the final correct ID
  // This heals the vault if it was empty or had wrong ID
  try {
    await despia(`setvault://?key=app_user_id&value=${result.appUserId}&locked=false`);
  } catch (error) {
    console.log('Vault write failed:', error);
  }
  
  // Update services with final ID
  despia(`setonesignalplayerid://?user_id=${result.appUserId}`);
  despia(`setrevenuecatuserid://?user_id=${result.appUserId}`);
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web login setup...
  // Use your web auth system (Supabase Auth, Auth0, etc.)
}
```

### User Logout

```javascript
// ==========================================
// USER LOGOUT - Reset to new anonymous identity
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  // Generate new anonymous identity
  const newAppUserId = despia.uuid;
  
  // Update vault
  await despia(`setvault://?key=app_user_id&value=${newAppUserId}&locked=false`);
  
  // Update services
  despia(`setonesignalplayerid://?user_id=${newAppUserId}`);
  despia(`setrevenuecatuserid://?user_id=${newAppUserId}`);
  
  // Register new anonymous user with backend
  await fetch('/api/user/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      appUserId: newAppUserId,
      deviceId: despia.uuid,
      platform: ua.includes('android') ? 'android' : 'ios',
      timestamp: new Date().toISOString()
    })
  });
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web logout setup...
}
```

### Account Switch

```javascript
// ==========================================
// ACCOUNT SWITCH - Multi-account users
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  // Get the target account's app_user_id
  const response = await fetch(`/api/user/get-app-user-id/${newAccountId}`);
  const result = await response.json();
  
  if (result.appUserId) {
    // Update vault
    await despia(`setvault://?key=app_user_id&value=${result.appUserId}&locked=false`);
    
    // Update services
    despia(`setonesignalplayerid://?user_id=${result.appUserId}`);
    despia(`setrevenuecatuserid://?user_id=${result.appUserId}`);
  }
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web account switch setup...
}
```

### Push Permission (Manual Mode)

```javascript
// ==========================================
// REQUEST PUSH PERMISSION (Manual Mode only)
// Call during onboarding after showing app value
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  despia('registerpush://');
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web push permission setup...
  // Notification.requestPermission()
}
```

### Sync Push Permission Status

```javascript
// ==========================================
// SYNC PUSH PERMISSION STATUS
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  const permissionData = await despia('checkNativePushPermissions://', ['nativePushEnabled']);
  const pushEnabled = permissionData.nativePushEnabled;
  
  await fetch('/api/push/permission', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      appUserId,
      deviceId: despia.uuid,
      pushEnabled,
      timestamp: new Date().toISOString()
    })
  });
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web push permission check...
  // const permission = Notification.permission;
}
```

### Open Push Settings

```javascript
// ==========================================
// OPEN PUSH SETTINGS - Re-engage users who disabled push
// ==========================================

const ua = navigator.userAgent.toLowerCase();
const isDespia = ua.includes('despia');

if (isDespia) {
  // -----------------------------------------
  // NATIVE APP (Despia)
  // -----------------------------------------
  
  despia('settingsapp://');
  
} else {
  // -----------------------------------------
  // WEB BROWSER
  // -----------------------------------------
  
  // Web settings setup...
  // Show instructions to enable in browser settings
}
```

---

## Backend Implementation

### User Registration Handler

```javascript
const ONESIGNAL_APP_ID = process.env.ONESIGNAL_APP_ID;
const ONESIGNAL_REST_API_KEY = process.env.ONESIGNAL_REST_API_KEY;

/**
 * Register user (anonymous or returning)
 * POST /api/user/register
 */
async function handleUserRegistration(req, res) {
  try {
    const { appUserId, deviceId, platform, appVersion, timestamp } = req.body;
    
    if (!appUserId || !deviceId) {
      return res.status(400).json({ error: 'appUserId and deviceId required' });
    }
    
    console.log(`Registering user: ${appUserId}`);
    
    // Check if user exists
    const existingUser = await getUserByAppUserId(appUserId);
    
    if (existingUser) {
      // Update last seen
      await updateUserLastSeen(appUserId, deviceId, timestamp);
      
      return res.status(200).json({
        success: true,
        appUserId,
        isReturning: true,
        accountId: existingUser.account_id
      });
    }
    
    // Create new user
    await createUser({
      app_user_id: appUserId,
      device_id: deviceId,
      platform,
      app_version: appVersion,
      is_anonymous: true,
      account_id: null,
      push_enabled: true,
      created_at: timestamp,
      last_seen: timestamp
    });
    
    return res.status(200).json({
      success: true,
      appUserId,
      isReturning: false,
      accountId: null
    });
    
  } catch (error) {
    console.error('Registration error:', error);
    return res.status(500).json({ error: 'Failed to register user' });
  }
}

/**
 * Handle login - CLAIM or RECOVER identity
 * POST /api/user/login
 */
async function handleUserLogin(req, res) {
  try {
    const { accountId, currentAppUserId, deviceId, platform, timestamp } = req.body;
    
    if (!accountId || !currentAppUserId) {
      return res.status(400).json({ error: 'accountId and currentAppUserId required' });
    }
    
    console.log(`Login for account ${accountId}, current app_user_id: ${currentAppUserId}`);
    
    // Check if account already has an app_user_id
    const existingAccount = await getAccountAppUserId(accountId);
    
    if (existingAccount && existingAccount.app_user_id) {
      // ==========================================
      // RECOVER: Account already has app_user_id
      // ==========================================
      
      console.log(`Account ${accountId} recovering: ${existingAccount.app_user_id}`);
      
      // Check for anonymous data to merge
      let mergedAnonymousData = false;
      if (currentAppUserId !== existingAccount.app_user_id) {
        const anonymousUser = await getUserByAppUserId(currentAppUserId);
        
        if (anonymousUser && anonymousUser.is_anonymous) {
          await mergeAnonymousUserData(currentAppUserId, accountId);
          await markUserMerged(currentAppUserId, accountId);
          mergedAnonymousData = true;
        }
      }
      
      // Update device registration
      await updateDeviceRegistration(deviceId, {
        app_user_id: existingAccount.app_user_id,
        account_id: accountId,
        last_seen: timestamp
      });
      
      return res.status(200).json({
        success: true,
        action: 'recovered',
        appUserId: existingAccount.app_user_id,
        mergedAnonymousData
      });
      
    } else {
      // ==========================================
      // CLAIM: Account doesn't have app_user_id
      // ==========================================
      
      console.log(`Account ${accountId} claiming: ${currentAppUserId}`);
      
      // Assign app_user_id to account
      await assignAppUserIdToAccount(accountId, currentAppUserId);
      
      // Update user record
      const anonymousUser = await getUserByAppUserId(currentAppUserId);
      let mergedAnonymousData = false;
      
      if (anonymousUser) {
        await claimUser(currentAppUserId, accountId);
        mergedAnonymousData = anonymousUser.is_anonymous && anonymousUser.has_data;
      } else {
        await createUser({
          app_user_id: currentAppUserId,
          device_id: deviceId,
          platform,
          is_anonymous: false,
          account_id: accountId,
          created_at: timestamp,
          last_seen: timestamp
        });
      }
      
      return res.status(200).json({
        success: true,
        action: 'claimed',
        appUserId: currentAppUserId,
        mergedAnonymousData
      });
    }
    
  } catch (error) {
    console.error('Login error:', error);
    return res.status(500).json({ error: 'Failed to process login' });
  }
}

/**
 * Get app_user_id for account (used for account switch)
 * GET /api/user/get-app-user-id/:accountId
 */
async function handleGetAppUserId(req, res) {
  try {
    const { accountId } = req.params;
    
    const account = await getAccountAppUserId(accountId);
    
    if (!account || !account.app_user_id) {
      return res.status(404).json({ error: 'No app_user_id for this account' });
    }
    
    return res.status(200).json({
      appUserId: account.app_user_id
    });
    
  } catch (error) {
    console.error('Get app_user_id error:', error);
    return res.status(500).json({ error: 'Failed to get app_user_id' });
  }
}

/**
 * Update push permission status
 * POST /api/push/permission
 */
async function handlePermissionUpdate(req, res) {
  try {
    const { appUserId, deviceId, pushEnabled, timestamp } = req.body;
    
    if (!appUserId || !deviceId) {
      return res.status(400).json({ error: 'appUserId and deviceId required' });
    }
    
    await updateDevicePermission(deviceId, pushEnabled, timestamp);
    await updateUserPushSummary(appUserId);
    
    await logPermissionChange({
      appUserId,
      deviceId,
      pushEnabled,
      changedAt: timestamp
    });
    
    return res.status(200).json({ success: true, pushEnabled });
    
  } catch (error) {
    console.error('Permission update error:', error);
    return res.status(500).json({ error: 'Failed to update permission' });
  }
}

module.exports = {
  handleUserRegistration,
  handleUserLogin,
  handleGetAppUserId,
  handlePermissionUpdate
};
```

### Send Notification Handler

```javascript
/**
 * Send notification to user(s)
 * POST /api/push/send
 */
async function handleSendNotification(req, res) {
  try {
    const {
      appUserIds,        // Array of app_user_ids
      title,
      message,
      data,
      url,
      buttons,
      scheduledAt,
      ttl,
      priority
    } = req.body;
    
    if (!appUserIds || !Array.isArray(appUserIds) || appUserIds.length === 0) {
      return res.status(400).json({ error: 'appUserIds array required' });
    }
    
    if (!message) {
      return res.status(400).json({ error: 'message required' });
    }
    
    // Filter users with push enabled
    const eligibleUsers = await getEligiblePushUsers(appUserIds);
    
    if (eligibleUsers.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No eligible users',
        sent: 0,
        skipped: appUserIds.length
      });
    }
    
    // Build OneSignal payload
    const payload = {
      app_id: ONESIGNAL_APP_ID,
      include_external_user_ids: eligibleUsers,  // app_user_id IS external_user_id
      contents: { en: message }
    };
    
    if (title) payload.headings = { en: title };
    if (data) payload.data = data;
    if (url) payload.url = url;
    if (buttons) payload.buttons = buttons.map(btn => ({ id: btn.id, text: btn.text }));
    if (scheduledAt) payload.send_after = scheduledAt;
    if (ttl) payload.ttl = ttl;
    if (priority === 'high') payload.priority = 10;
    
    // iOS settings
    payload.ios_sound = 'default';
    payload.ios_badgeType = 'Increase';
    payload.ios_badgeCount = 1;
    
    // Android settings
    if (process.env.ONESIGNAL_ANDROID_CHANNEL_ID) {
      payload.android_channel_id = process.env.ONESIGNAL_ANDROID_CHANNEL_ID;
    }
    
    // Send to OneSignal
    const result = await sendToOneSignal(payload);
    
    // Log notification
    await logNotification({
      notificationId: result.id,
      appUserIds: eligibleUsers,
      title,
      message,
      data,
      sentAt: new Date().toISOString(),
      status: result.errors ? 'partial' : 'sent',
      recipients: result.recipients
    });
    
    return res.status(200).json({
      success: true,
      notificationId: result.id,
      sent: eligibleUsers.length,
      skipped: appUserIds.length - eligibleUsers.length,
      recipients: result.recipients
    });
    
  } catch (error) {
    console.error('Send notification error:', error);
    return res.status(500).json({ error: 'Failed to send notification' });
  }
}

/**
 * Send to OneSignal API
 */
async function sendToOneSignal(payload) {
  const response = await fetch('https://onesignal.com/api/v1/notifications', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Basic ${ONESIGNAL_REST_API_KEY}`
    },
    body: JSON.stringify(payload)
  });
  
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`OneSignal API error: ${response.status} - ${errorText}`);
  }
  
  return await response.json();
}

/**
 * Get users with push enabled
 */
async function getEligiblePushUsers(appUserIds) {
  const result = await db.query(`
    SELECT DISTINCT app_user_id
    FROM app_users
    WHERE app_user_id = ANY($1)
      AND push_enabled = true
      AND last_seen > NOW() - INTERVAL '90 days'
  `, [appUserIds]);
  
  return result.rows.map(row => row.app_user_id);
}

module.exports = { handleSendNotification, sendToOneSignal };
```

---

## RevenueCat ‚Üí Push Integration

Send push notifications directly from RevenueCat webhook events using the same `app_user_id`:

```javascript
/**
 * Process RevenueCat webhook and send push notification
 * The app_user_id from the webhook IS the OneSignal external_user_id
 */
async function processWebhookEvent({ eventType, appUserId, event }) {
  // Sync entitlements to database
  await syncEntitlementsToDatabase(appUserId, event);
  
  // Send targeted push notifications
  switch (eventType) {
    
    case 'INITIAL_PURCHASE':
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: 'üéâ Welcome to Premium!' },
        contents: { en: 'Thank you for subscribing. Explore your new features!' },
        data: { type: 'purchase', screen: 'features' }
      });
      break;
      
    case 'TRIAL_STARTED':
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: 'üéâ Trial Started!' },
        contents: { en: 'Explore all premium features for the next 7 days.' },
        data: { type: 'trial', screen: 'onboarding' }
      });
      break;
      
    case 'BILLING_ISSUE':
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: '‚ö†Ô∏è Payment Issue' },
        contents: { en: 'Update your payment method to keep your subscription active.' },
        data: { type: 'billing', screen: 'subscription' },
        url: 'myapp://settings/subscription'
      });
      break;
      
    case 'CANCELLATION':
      // Schedule win-back notification for 24h later
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: 'Before you go...' },
        contents: { en: 'Tell us what we could do better?' },
        data: { type: 'feedback', screen: 'survey' },
        send_after: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()
      });
      break;
      
    case 'EXPIRATION':
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: 'We miss you! üëã' },
        contents: { en: 'Your subscription has ended. Come back for 20% off!' },
        data: { type: 'winback', promoCode: 'COMEBACK20' }
      });
      break;
      
    case 'RENEWAL':
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: '‚úÖ Subscription Renewed' },
        contents: { en: 'Thanks for staying with us!' },
        data: { type: 'renewal' }
      });
      break;
      
    case 'PRODUCT_CHANGE':
      const isUpgrade = event.new_product_id?.includes('yearly') || 
                        event.new_product_id?.includes('premium');
      await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: [appUserId],
        headings: { en: isUpgrade ? '‚¨ÜÔ∏è Plan Upgraded!' : 'Plan Changed' },
        contents: { en: isUpgrade ? 'Enjoy your new premium features!' : 'Your plan has been updated.' },
        data: { type: 'product_change', newProductId: event.new_product_id }
      });
      break;
  }
}
```

---

## Database Schema (SQL)

```sql
-- ==========================================
-- CORE USER IDENTITY TABLE
-- ==========================================

CREATE TABLE app_users (
  id SERIAL PRIMARY KEY,
  app_user_id VARCHAR(255) NOT NULL UNIQUE,  -- Universal ID
  device_id VARCHAR(255),
  platform VARCHAR(20) DEFAULT 'unknown',
  app_version VARCHAR(50),
  is_anonymous BOOLEAN DEFAULT true,
  account_id VARCHAR(255),
  claimed_at TIMESTAMP,
  merged_into_account VARCHAR(255),
  merged_at TIMESTAMP,
  has_data BOOLEAN DEFAULT false,
  push_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  last_seen TIMESTAMP NOT NULL
);

CREATE INDEX idx_app_users_id ON app_users(app_user_id);
CREATE INDEX idx_app_users_account ON app_users(account_id);
CREATE INDEX idx_app_users_anonymous ON app_users(is_anonymous) WHERE is_anonymous = true;
CREATE INDEX idx_app_users_last_seen ON app_users(last_seen);

-- ==========================================
-- DEVICE REGISTRATIONS
-- ==========================================

CREATE TABLE user_devices (
  id SERIAL PRIMARY KEY,
  device_id VARCHAR(255) NOT NULL UNIQUE,
  app_user_id VARCHAR(255) NOT NULL,
  account_id VARCHAR(255),
  platform VARCHAR(20) DEFAULT 'unknown',
  app_version VARCHAR(50),
  push_enabled BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW(),
  last_seen TIMESTAMP NOT NULL,
  FOREIGN KEY (app_user_id) REFERENCES app_users(app_user_id)
);

CREATE INDEX idx_devices_app_user ON user_devices(app_user_id);
CREATE INDEX idx_devices_account ON user_devices(account_id);

-- ==========================================
-- ACCOUNTS TABLE (add app_user_id column)
-- ==========================================

ALTER TABLE accounts 
  ADD COLUMN IF NOT EXISTS app_user_id VARCHAR(255) UNIQUE;

CREATE INDEX idx_accounts_app_user ON accounts(app_user_id);

-- ==========================================
-- SUBSCRIPTIONS (from RevenueCat webhooks)
-- ==========================================

CREATE TABLE user_subscriptions (
  id SERIAL PRIMARY KEY,
  app_user_id VARCHAR(255) UNIQUE NOT NULL,  -- Same universal ID
  account_id VARCHAR(255),
  email VARCHAR(255),
  is_active BOOLEAN DEFAULT false,
  subscription_status VARCHAR(50),
  product_id VARCHAR(255),
  entitlements JSONB,
  expires_at TIMESTAMP,
  purchased_at TIMESTAMP,
  cancelled_at TIMESTAMP,
  billing_issue BOOLEAN DEFAULT false,
  store VARCHAR(50),
  environment VARCHAR(20),
  last_webhook_event_id VARCHAR(255),
  last_webhook_event_type VARCHAR(100),
  last_updated TIMESTAMP DEFAULT NOW(),
  created_at TIMESTAMP DEFAULT NOW(),
  FOREIGN KEY (app_user_id) REFERENCES app_users(app_user_id)
);

CREATE INDEX idx_subscriptions_app_user ON user_subscriptions(app_user_id);
CREATE INDEX idx_subscriptions_active ON user_subscriptions(is_active);
CREATE INDEX idx_subscriptions_status ON user_subscriptions(subscription_status);

-- ==========================================
-- NOTIFICATION LOGS
-- ==========================================

CREATE TABLE notification_logs (
  id SERIAL PRIMARY KEY,
  notification_id VARCHAR(255),
  app_user_ids JSONB NOT NULL,
  title VARCHAR(255),
  message TEXT NOT NULL,
  data JSONB,
  sent_at TIMESTAMP NOT NULL,
  status VARCHAR(50) DEFAULT 'sent',
  recipient_count INTEGER,
  trigger_event VARCHAR(100),  -- e.g., 'BILLING_ISSUE', 'EXPIRATION'
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_notifications_sent ON notification_logs(sent_at);
CREATE INDEX idx_notifications_trigger ON notification_logs(trigger_event);

-- ==========================================
-- PERMISSION CHANGE LOGS
-- ==========================================

CREATE TABLE push_permission_logs (
  id SERIAL PRIMARY KEY,
  app_user_id VARCHAR(255) NOT NULL,
  device_id VARCHAR(255) NOT NULL,
  push_enabled BOOLEAN NOT NULL,
  changed_at TIMESTAMP NOT NULL
);

CREATE INDEX idx_permission_logs_app_user ON push_permission_logs(app_user_id);

-- ==========================================
-- IDENTITY MERGE AUDIT LOG
-- ==========================================

CREATE TABLE identity_merges (
  id SERIAL PRIMARY KEY,
  anonymous_app_user_id VARCHAR(255) NOT NULL,
  target_account_id VARCHAR(255) NOT NULL,
  target_app_user_id VARCHAR(255) NOT NULL,
  data_merged JSONB,
  merged_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_merges_account ON identity_merges(target_account_id);
```

---

## Rate Limiting

OneSignal limits: **1 request per second**

```javascript
const RATE_LIMIT = {
  MS_BETWEEN_REQUESTS: 1250,  // 1.25 seconds (safe margin)
  MAX_BATCH_SIZE: 2000        // OneSignal limit per request
};

/**
 * Send to large audience with rate limiting
 */
async function sendToLargeAudience(appUserIds, title, message, data) {
  // Split into batches
  const batches = [];
  for (let i = 0; i < appUserIds.length; i += RATE_LIMIT.MAX_BATCH_SIZE) {
    batches.push(appUserIds.slice(i, i + RATE_LIMIT.MAX_BATCH_SIZE));
  }
  
  console.log(`Sending to ${appUserIds.length} users in ${batches.length} batches`);
  
  const results = [];
  
  for (let i = 0; i < batches.length; i++) {
    try {
      const result = await sendToOneSignal({
        app_id: ONESIGNAL_APP_ID,
        include_external_user_ids: batches[i],
        headings: title ? { en: title } : undefined,
        contents: { en: message },
        data
      });
      
      results.push({ batch: i, success: true, recipients: result.recipients });
      
    } catch (error) {
      results.push({ batch: i, success: false, error: error.message });
      
      // Back off on rate limit
      if (error.message.includes('429')) {
        await sleep(5000);
      }
    }
    
    // Rate limiting
    if (i < batches.length - 1) {
      await sleep(RATE_LIMIT.MS_BETWEEN_REQUESTS);
    }
  }
  
  return {
    total: appUserIds.length,
    batches: batches.length,
    successful: results.filter(r => r.success).length,
    results
  };
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

---

## Environment Variables

```dotenv
# OneSignal
ONESIGNAL_APP_ID=your_onesignal_app_id
ONESIGNAL_REST_API_KEY=your_rest_api_key
ONESIGNAL_ANDROID_CHANNEL_ID=your_android_channel_id  # Optional

# RevenueCat
REVENUECAT_API_KEY=your_revenuecat_api_key
REVENUECAT_PROJECT_ID=your_project_id
REVENUECAT_WEBHOOK_SECRET=your_webhook_secret

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
```

---

## Quick Checklist

**Configuration:**

- OneSignal account created with iOS/Android configured
- OneSignal App ID added to Despia dashboard
- REST API Key stored in backend environment
- Decide: Auto mode (default) or Manual mode?

**User Identity System:**

- `app_users` table created
- `user_devices` table created
- `app_user_id` column added to accounts table
- `/api/user/register` endpoint implemented
- `/api/user/login` endpoint with CLAIM + RECOVER logic
- `/api/user/get-app-user-id/:accountId` endpoint

**Frontend:**

- `initializeAppUserId()` called on every app launch
- `app_user_id` stored in Storage Vault
- `registerUser()` sets OneSignal AND RevenueCat IDs
- `handleLogin()` handles CLAIM/RECOVER flow
- `handleLogout()` creates new anonymous identity
- If Manual Mode: `registerpush://` called during onboarding

**RevenueCat Integration:**

- Webhook handler sends push notifications using `app_user_id`
- Same `app_user_id` used for RevenueCat and OneSignal

**Testing:**

- Anonymous user can receive notifications
- Login correctly claims/recovers `app_user_id`
- Logout creates new anonymous identity
- RevenueCat webhook triggers push notification
- Multi-device sync works
- Permission change sync works

---

## Additional Resources

**Despia Features:**

- [Storage Vault](https://setup.despia.com/native-features/storage-vault) ‚Äî Critical for `app_user_id` persistence
- [RevenueCat Webhooks](https://setup.despia.com/best-practices/backend/revenue-cat/webhooks) ‚Äî Subscription event handling
- [Local Push Notifications](https://setup.despia.com/native-features/offline-push)
- [App Settings Deep Link](https://setup.despia.com/native-features/app-settings)

**External Documentation:**

- [OneSignal REST API](https://documentation.onesignal.com/reference/create-notification)
- [OneSignal External User IDs](https://documentation.onesignal.com/docs/external-user-ids)
- [RevenueCat Webhooks](https://www.revenuecat.com/docs/integrations/webhooks)